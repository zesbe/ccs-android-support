/**
 * Config Generator for CLIProxyAPI
 *
 * Generates config.yaml for CLIProxyAPI based on provider.
 * Handles OAuth token paths and provider-specific settings.
 *
 * Model mappings are loaded from config/base-{provider}.settings.json files
 * to allow easy updates without code changes.
 */

import * as fs from 'fs';
import * as path from 'path';
import { getCcsDir } from '../utils/config-manager';
import { CLIProxyProvider, ProviderConfig, ProviderModelMapping } from './types';
import { getModelMappingFromConfig } from './base-config-loader';

/** Settings file structure for user overrides */
interface ProviderSettings {
  env: NodeJS.ProcessEnv;
}

/** Default CLIProxy port */
export const CLIPROXY_DEFAULT_PORT = 8317;

/** Internal API key for CCS-managed requests */
const CCS_INTERNAL_API_KEY = 'ccs-internal-managed';

/** Provider display names (static metadata) */
const PROVIDER_DISPLAY_NAMES: Record<CLIProxyProvider, string> = {
  gemini: 'Gemini',
  codex: 'Codex',
  agy: 'Antigravity',
  qwen: 'Qwen Code',
};

/**
 * Get provider configuration
 * Model mappings are loaded from config/base-{provider}.settings.json
 */
export function getProviderConfig(provider: CLIProxyProvider): ProviderConfig {
  const displayName = PROVIDER_DISPLAY_NAMES[provider];
  if (!displayName) {
    throw new Error(`Unknown provider: ${provider}`);
  }

  // Load models from base config file
  const models = getModelMappingFromConfig(provider);

  return {
    name: provider,
    displayName,
    models,
    requiresOAuth: true, // All CLIProxy providers require OAuth
  };
}

/**
 * Get model mapping for provider
 * Loads from config/base-{provider}.settings.json
 */
export function getModelMapping(provider: CLIProxyProvider): ProviderModelMapping {
  return getProviderConfig(provider).models;
}

/**
 * Get CLIProxy base directory
 * All CLIProxy-related files are stored under ~/.ccs/cliproxy/
 */
export function getCliproxyDir(): string {
  return path.join(getCcsDir(), 'cliproxy');
}

/**
 * Get auth directory for provider
 * All providers use a FLAT auth directory structure for unified config.
 * CLIProxyAPI stores OAuth tokens directly in auth/ (not subdirectories).
 * This enables all providers to be discovered and used concurrently.
 */
export function getProviderAuthDir(_provider: CLIProxyProvider): string {
  // Use flat structure - all auth files in same directory for unified discovery
  // Provider param kept for API compatibility (CLIProxyAPI handles via auth file type field)
  return path.join(getCliproxyDir(), 'auth');
}

/**
 * Get base auth directory for CLIProxyAPI
 */
export function getAuthDir(): string {
  return path.join(getCliproxyDir(), 'auth');
}

/**
 * Get config file path
 */
export function getConfigPath(): string {
  return path.join(getCliproxyDir(), 'config.yaml');
}

/**
 * Get binary directory path
 */
export function getBinDir(): string {
  return path.join(getCliproxyDir(), 'bin');
}

/**
 * Generate UNIFIED config.yaml content for ALL providers
 * This enables concurrent usage of gemini/codex/agy without config conflicts.
 * CLIProxyAPI routes requests by model name to the appropriate provider.
 */
function generateUnifiedConfigContent(port: number = CLIPROXY_DEFAULT_PORT): string {
  const authDir = getAuthDir(); // Base auth dir - CLIProxyAPI scans subdirectories

  // Unified config with all providers
  const config = `# CLIProxyAPI unified config generated by CCS
# Supports: gemini, codex, agy, qwen (concurrent usage)
# Generated: ${new Date().toISOString()}

port: ${port}
debug: false
logging-to-file: false
usage-statistics-enabled: false

# CCS internal authentication
api-keys:
  - "${CCS_INTERNAL_API_KEY}"

# OAuth tokens stored in auth/ directory
# CLIProxyAPI auto-discovers auth files in subdirectories
auth-dir: "${authDir}"

# All providers configured - routes by model name
# No provider-specific sections needed - OAuth auth files provide credentials
`;

  return config;
}

/**
 * Generate unified config.yaml file (supports all providers concurrently)
 * Only regenerates if config doesn't exist.
 * @returns Path to config file
 */
export function generateConfig(
  provider: CLIProxyProvider,
  port: number = CLIPROXY_DEFAULT_PORT
): string {
  const configPath = getConfigPath();

  // Ensure provider auth directory exists
  const authDir = getProviderAuthDir(provider);
  fs.mkdirSync(path.dirname(configPath), { recursive: true });
  fs.mkdirSync(authDir, { recursive: true, mode: 0o700 });

  // Only generate config if it doesn't exist (unified config serves all providers)
  if (!fs.existsSync(configPath)) {
    const configContent = generateUnifiedConfigContent(port);
    fs.writeFileSync(configPath, configContent, { mode: 0o600 });
  }

  return configPath;
}

/**
 * Check if config exists for provider
 */
export function configExists(): boolean {
  return fs.existsSync(getConfigPath());
}

/**
 * Delete config file
 */
export function deleteConfig(): void {
  const configPath = getConfigPath();
  if (fs.existsSync(configPath)) {
    fs.unlinkSync(configPath);
  }
}

/**
 * Get path to user settings file for provider
 * Example: ~/.ccs/gemini.settings.json
 */
export function getProviderSettingsPath(provider: CLIProxyProvider): string {
  return path.join(getCcsDir(), `${provider}.settings.json`);
}

/**
 * Get environment variables for Claude CLI (bundled defaults)
 * Uses provider-specific endpoint (e.g., /api/provider/gemini) for explicit routing.
 * This enables concurrent gemini/codex usage - each session routes to its provider via URL path.
 */
export function getClaudeEnvVars(
  provider: CLIProxyProvider,
  port: number = CLIPROXY_DEFAULT_PORT
): NodeJS.ProcessEnv {
  const models = getModelMapping(provider);

  return {
    // Provider-specific endpoint - routes to correct provider via URL path
    ANTHROPIC_BASE_URL: `http://127.0.0.1:${port}/api/provider/${provider}`,
    ANTHROPIC_AUTH_TOKEN: CCS_INTERNAL_API_KEY,
    ANTHROPIC_MODEL: models.claudeModel,
    ANTHROPIC_DEFAULT_OPUS_MODEL: models.opusModel || models.claudeModel,
    ANTHROPIC_DEFAULT_SONNET_MODEL: models.sonnetModel || models.claudeModel,
    ANTHROPIC_DEFAULT_HAIKU_MODEL: models.haikuModel || models.claudeModel,
  };
}

/**
 * Get effective environment variables for provider
 *
 * Priority order:
 * 1. Custom settings path (for user-defined CLIProxy variants)
 * 2. User settings file (~/.ccs/{provider}.settings.json) if exists
 * 3. Bundled defaults from PROVIDER_CONFIGS
 *
 * This allows users to customize model mappings without code changes.
 * User takes full responsibility for custom settings.
 */
export function getEffectiveEnvVars(
  provider: CLIProxyProvider,
  port: number = CLIPROXY_DEFAULT_PORT,
  customSettingsPath?: string
): NodeJS.ProcessEnv {
  // Priority 1: Custom settings path (for user-defined variants)
  if (customSettingsPath) {
    const expandedPath = customSettingsPath.replace(/^~/, require('os').homedir());
    if (fs.existsSync(expandedPath)) {
      try {
        const content = fs.readFileSync(expandedPath, 'utf-8');
        const settings: ProviderSettings = JSON.parse(content);

        if (settings.env && typeof settings.env === 'object') {
          // Custom variant settings found - use them
          return settings.env;
        }
      } catch {
        // Invalid JSON - fall through to provider defaults
        console.warn(`[!] Warning: Invalid settings file: ${customSettingsPath}`);
      }
    } else {
      console.warn(`[!] Warning: Settings file not found: ${customSettingsPath}`);
    }
  }

  // Priority 2: Default provider settings file
  const settingsPath = getProviderSettingsPath(provider);

  // Check for user override file
  if (fs.existsSync(settingsPath)) {
    try {
      const content = fs.readFileSync(settingsPath, 'utf-8');
      const settings: ProviderSettings = JSON.parse(content);

      if (settings.env && typeof settings.env === 'object') {
        // User override found - use their settings
        // Note: User is responsible for correctness
        return settings.env;
      }
    } catch {
      // Invalid JSON or structure - fall through to defaults
      // Silent fallback: don't spam errors for broken user files
    }
  }

  // No override or invalid - use bundled defaults
  return getClaudeEnvVars(provider, port);
}

/**
 * Copy bundled settings template to user directory if not exists
 * Called during installation/first run
 */
export function ensureProviderSettings(provider: CLIProxyProvider): void {
  const settingsPath = getProviderSettingsPath(provider);

  // Only create if doesn't exist (preserve user edits)
  if (fs.existsSync(settingsPath)) {
    return;
  }

  // Generate default settings from PROVIDER_CONFIGS
  const envVars = getClaudeEnvVars(provider);
  const settings: ProviderSettings = { env: envVars };

  // Ensure directory exists
  fs.mkdirSync(path.dirname(settingsPath), { recursive: true });

  // Write with restricted permissions
  fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2) + '\n', {
    mode: 0o600,
  });
}
